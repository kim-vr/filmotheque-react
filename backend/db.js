const mongoose=require("mongoose");mongoose.set("strictQuery",!1);const PostSchema=new mongoose.Schema({content:{type:String,required:!0},author:{type:String,required:!0},movie:{type:String,required:!0},created:{type:Date,default:Date.now}}),Post=mongoose.model("Post",PostSchema),FavoriteSchema=new mongoose.Schema({user:{type:String,required:!0},movie:{type:String,required:!0},created:{type:Date,default:Date.now}}),Favorite=mongoose.model("Favorite",FavoriteSchema);let dbConnection=null;const connectDB=async function(t){if(!dbConnection)try{await mongoose.connect("mongodb+srv://admin-postDB:LGUTcHiTSmM3TgjW@cluster0.lqlcvk8.mongodb.net/postsDB"),dbConnection=await mongoose.connection}catch(t){console.log("Erreur de connexion!",t)}},closeDB=()=>{dbConnection?.close(),dbConnection=null},findPostByAny=async(t={})=>{try{return await connectDB(),await Post.find(t).sort({created:-1})}catch(t){throw t}},findPostById=async t=>{if(!mongoose.isValidObjectId(t))throw t+"n'est pas une reférence valide !";try{return await connectDB(),await Post.findById(t)}catch(t){throw t}},findPostByAuthor=async t=>{try{return await connectDB(),await Post.find({author:t}).sort({created:-1})}catch(t){throw t}},findPostByMovie=async t=>{try{return await connectDB(),await Post.find({movie:t}).sort({created:-1})}catch(t){throw t}},addPost=async(t,e,o)=>{if(void 0===t||void 0===e||void 0===o)throw"author/movie/content : obligatoire !";try{await connectDB();const n=new Post({author:t,movie:e,content:o});return await n.save()}catch(t){throw t}},updatePost=async(t,e,o,n)=>{if(!mongoose.isValidObjectId(t))throw t+"n'est pas une reférence valide !";try{return await connectDB(),await Post.findByIdAndUpdate(t,{author:e,movie:o,content:n},{new:!0,upsert:!0})}catch(t){throw t}},deletePost=async t=>{if(!mongoose.isValidObjectId(t))throw t+"n'est pas une reférence valide !";try{return await connectDB(),await Post.findByIdAndDelete(t)}catch(t){throw t}},findFavoriteByAny=async(t={})=>{try{return await connectDB(),await Favorite.find(t).sort({created:-1})}catch(t){throw t}},findFavoriteById=async t=>{if(!mongoose.isValidObjectId(t))throw t+"n'est pas une reférence valide !";try{return await connectDB(),await Favorite.findById(t)}catch(t){throw t}},findFavoriteByUser=async t=>{try{return await connectDB(),await Favorite.find({user:t}).sort({created:-1})}catch(t){throw t}},findFavoriteByMovie=async t=>{try{return await connectDB(),await Favorite.find({movie:t}).sort({created:-1})}catch(t){throw t}},addFavorite=async(t,e)=>{if(void 0===t||void 0===e)throw"user/movie : obligatoire !";try{await connectDB();const o=new Favorite({user:t,movie:e});return await o.save()}catch(t){throw t}},updateFavorite=async(t,e,o)=>{if(!mongoose.isValidObjectId(t))throw t+"n'est pas une reférence valide !";try{return await connectDB(),await Favorite.findByIdAndUpdate(t,{user:e,movie:o},{new:!0,upsert:!0})}catch(t){throw t}},deleteFavorite=async t=>{if(!mongoose.isValidObjectId(t))throw t+"n'est pas une reférence valide !";try{return await connectDB(),await Favorite.findByIdAndDelete(t)}catch(t){throw t}};module.exports={findPostByAny:findPostByAny,findPostById:findPostById,findPostByAuthor:findPostByAuthor,findPostByMovie:findPostByMovie,addPost:addPost,updatePost:updatePost,deletePost:deletePost,findFavoriteByAny:findFavoriteByAny,findFavoriteById:findFavoriteById,findFavoriteByUser:findFavoriteByUser,findFavoriteByMovie:findFavoriteByMovie,addFavorite:addFavorite,updateFavorite:updateFavorite,deleteFavorite:deleteFavorite};